package bgn

import (
	"crypto/rand"
	"errors"
	"log"
	"math/big"
	"strconv"
	"strings"

	"github.com/Nik-U/pbc"
)

// PublicKey is the BGN public key used for encryption
// as well as performing homomorphic operations on ciphertexts
type PublicKey struct {
	Pairing *pbc.Pairing
	G1      *pbc.Element
	GT      *pbc.Element
	P       *pbc.Element
	Q       *pbc.Element
	N       *big.Int
}

// SecretKey used for decryption of ciphertexts
type SecretKey struct {
	key *big.Int
}

// SecretKeyShare is a share of a secret key
type SecretKeyShare struct {
	share *big.Int
}

// NewMPKeyGen generates a new public key and n shares of a secret key
func NewMPKeyGen(bits int, n int) (*PublicKey, []*SecretKeyShare, error) {

	// generate standard key pair
	var sk *SecretKey
	pk, sk, err := NewKeyGen(bits)

	if err != nil {
		return nil, nil, err
	}

	// secret key shares
	var shares []*SecretKeyShare

	// max value of each share (no bigger than sk/n)
	max := big.NewInt(0).Div(sk.key, big.NewInt(int64(n)))

	// sum of all the shares
	sum := big.NewInt(0)

	// compute shares
	for i := 0; i < n-1; i++ {
		// create new random share
		next := newCryptoRandom(max)
		shares = append(shares, &SecretKeyShare{next})
		sum = big.NewInt(0).Add(sum, next)
	}

	// last share should be computed so as to
	// have all shares add up to sk
	last := big.NewInt(0).Sub(sk.key, sum)
	shares = append(shares, &SecretKeyShare{last})

	return pk, shares, err
}

// NewKeyGen creates a new public/private key pair of size bits
func NewKeyGen(bits int) (*PublicKey, *SecretKey, error) {

	if bits < 128 {
		return nil, nil, errors.New("key bits must be > 128")
	}

	var r *big.Int     // random prime
	var q *big.Int     // secret key (random prime)
	var n *big.Int     // n = r*q
	var l *big.Int     // small number generated by pbc
	var P *pbc.Element // field element
	var Q *pbc.Element // field element

	// generate a new random prime r
	r, err := rand.Prime(rand.Reader, bits)

	// generate a new random prime q (this will be the secret key)
	q, err = rand.Prime(rand.Reader, bits)

	if err != nil {
		return nil, nil, err
	}

	// compute the product of the primes
	n = r.Mul(r, q)
	params := pbc.GenerateA1(n)

	// obtain l generated from the pbc library
	// is a "small" number s.t. p + 1 = l*n
	l, err = parseLFromParams(params)

	if err != nil {
		return nil, nil, err
	}

	// create a new pairing with given params
	pairing := pbc.NewPairing(params)

	// generate the two multiplicative groups of
	// order n (using pbc pairing library)
	G1 := pairing.NewG1()
	GT := pairing.NewGT()

	// choose random point P in G1
	P = G1.Rand()
	P = P.MulBig(P, l)

	// choose random Q in G1
	Q = G1.NewFieldElement()
	Q = Q.Set(P)
	Q = Q.MulBig(Q, r)

	// create public key with the generated groups
	pk := &PublicKey{pairing, G1, GT, P, Q, n}

	// create secret key
	sk := &SecretKey{q}

	return pk, sk, err
}

// Encrypt a given message m with the public key pk
func (pk *PublicKey) Encrypt(m *big.Int) *pbc.Element {

	u := newCryptoRandom(pk.N)
	A := pk.G1.NewFieldElement()
	B := pk.G1.NewFieldElement()
	C := pk.G1.NewFieldElement()

	A.Set(pk.P)
	A.MulBig(A, m)

	B.Set(pk.Q)
	B.MulBig(B, u)

	C.Set(A)
	C.Add(C, B)

	return C
}

// Decrypt a level 1 (non-multiplied) ciphertext C using secret key sk
func (sk *SecretKey) Decrypt(C *pbc.Element, pk *PublicKey) *big.Int {

	T := pk.G1.NewFieldElement()
	K := pk.G1.NewFieldElement()
	aux := pk.G1.NewFieldElement()

	T.Set(pk.P)
	T.MulBig(T, sk.key)

	K.Set(C)
	K.MulBig(K, sk.key)

	aux.Set(T)

	// brute force compute the discrete log
	// TODO: use kangaroo!
	m := big.NewInt(1)

	for {
		if aux.Equals(K) {
			break
		}

		aux = aux.Add(aux, T)
		m = m.Add(m, big.NewInt(1))
	}

	return m
}

// Decrypt2 a level 2 (multiplied) ciphertext C using secret key sk
func (sk *SecretKey) Decrypt2(C *pbc.Element, pk *PublicKey) *big.Int {

	psk := pk.GT.Pair(pk.P, pk.P)
	psk = psk.PowBig(psk, sk.key)

	csk := C.NewFieldElement()
	csk.Set(C)
	csk.PowBig(csk, sk.key)

	aux := psk.NewFieldElement()
	aux.Set(psk)

	// brute force compute the discrete log
	// TODO: use kangaroo!
	m := big.NewInt(1)

	for {
		if aux.Equals(csk) {
			break
		}

		aux = aux.Mul(aux, psk)
		m = m.Add(m, big.NewInt(1))
	}

	return m
}

// EAdd adds two level 1 (non-multiplied) ciphertexts together and returns the result
func (pk *PublicKey) EAdd(element1 *pbc.Element, element2 *pbc.Element) *pbc.Element {

	u := newCryptoRandom(pk.N)
	result := pk.G1.NewFieldElement()
	aux := pk.G1.NewFieldElement()

	aux.Set(pk.Q)
	aux.MulBig(aux, u)

	result.Set(element1)
	result.Add(result, element2)
	result.Add(result, aux)

	return result
}

// EAdd2 adds two level 2 (multiplied) ciphertexts together and returns the result
func (pk *PublicKey) EAdd2(element1 *pbc.Element, element2 *pbc.Element) *pbc.Element {

	u := newCryptoRandom(pk.N)
	result := pk.GT.NewFieldElement()

	K := pk.GT.Pair(pk.Q, pk.Q)
	K = K.PowBig(K, u)

	result.Set(element1)
	result = result.Mul(result, element2)
	result = result.Mul(result, K)

	return result
}

// EMultC multiplies a level 1 (non-multiplied) ciphertext with a plaintext constant
// and returns the result
func (pk *PublicKey) EMultC(element1 *pbc.Element, constant *big.Int) *pbc.Element {

	u := newCryptoRandom(pk.N)
	result := pk.G1.NewFieldElement()

	aux := pk.G1.NewFieldElement()
	aux.Set(pk.Q)
	aux.MulBig(aux, u)

	result.Set(element1)
	result.MulBig(element1, constant)
	result.Add(result, aux)

	return result
}

// EMultC2 multiplies a level 2 (multiplied) ciphertext with a plaintext constant
// and returns the result
func (pk *PublicKey) EMultC2(element1 *pbc.Element, constant *big.Int) *pbc.Element {

	u := newCryptoRandom(pk.N)
	result := pk.GT.NewFieldElement()

	K := pk.GT.Pair(pk.Q, pk.Q)
	K = K.PowBig(K, u)

	result.Set(element1)
	result.MulBig(result, constant)
	result.Mul(result, K)

	return result
}

// EMult multiplies two level 1 (non-multiplied) ciphertext together and returns the result
func (pk *PublicKey) EMult(element1 *pbc.Element, element2 *pbc.Element) *pbc.Element {

	u := newCryptoRandom(pk.N)
	result := pk.GT.NewFieldElement()

	T := pk.GT.Pair(element1, element2)
	K := pk.Pairing.NewGT().Pair(pk.Q, pk.Q)

	K.PowBig(K, u)
	result.Mul(T, K)

	return result
}

// generates a new random number < max
func newCryptoRandom(max *big.Int) *big.Int {
	rand, err := rand.Int(rand.Reader, max)
	if err != nil {
		log.Println(err)
	}

	return rand
}

// TOTAL HACK to access the generated "l" in the C struct
// which the PBC library holds. The golang wrapper has
// no means of accessing the struct variable without
// knowing the exact memory mapping. Better approach
// would be to either compute l on the fly or figure
// out the memory mapping between the C struct and
// golang equivalent
func parseLFromParams(params *pbc.Params) (*big.Int, error) {

	paramsStr := params.String()
	lStr := paramsStr[strings.Index(paramsStr, "l")+2 : len(paramsStr)-1]
	lInt, err := strconv.ParseInt(lStr, 10, 64)
	if err != nil {
		return nil, err
	}

	return big.NewInt(lInt), nil
}
